## 										Ajax数据交互

>何为数据交互?  =>  前后端数据的交互 (前端向后端发起数据请求 ,由后端响应数据给前端)
>
>Ajax : 在浏览器与服务器之间异步加载数据 . (web2.0重要技术) 可以在不重载整个页面的情况下 ,更新页面的某一块内容 

> ##### 因涉及后端数据交互 ,所以需要有后端服务.(后台 / 服务器环境)

##### 准备工作: 搭建一个本地开发测试(服务器)环境 

搭建一台本地的web服务器 ,让自己的pc充当为一台本地的服务器(其实就是一台性能比普通电脑更高的电脑,24小时不关机,给其他的pc或终端提供服务使用).

目前主流的服务器的操作系统:

1. windows server 2008 (窗口式操作)
2. Linux (centOS )
3. Unix

常见的服务:

​	web服务:搭建网站提供给互联网用户访问

​	smtp服务: 提供电子邮件发送服务

​	ftp服务: 提供文件共享服务(传输)

---

##### 常用于搭建web服务的软件:

1. IIS 微软 因特网信息服务  (运行在windows服务器上)

2. Apache  (linux , windows)

3. Nginx (linux) (推荐 ,服务器首选)

4. Nodejs  (linux , windows)

5. Tomcat  (linux , windows)

   ###### 在真实项目的上一般会选用Linux操作系统(nginx / apache)的服务器 (小型,或者个人项目可能会使用IIS的windows服务)	

​	本地的开发测试环境 ,可以使用一些集成的环境 = > XAMPP

​	XAMPP集成:

​			1.Apache (阿帕奇服务)

​			2.PHP (后端语言)

​			3.Mysql (数据库)

​			4.FileZilla ( FTP 服务 )	

​			5.Tomcat (运行java web的服务)		

---

安装完 XAMPP 打开控制面板 ,start 启动 apache 服务 ,服务默认会运行在80端口  , 

###### 	访问方式:

​	(本地)

1. http://localhost  (localhost 是本地的主机名称 , 只能访问当前设备上的服务) 

2. http://127.0.0.1 (所有的网络设备 ,都有一个本地的回路地址 : 127.0.0.1 )

   ###### 可以访问其他的网络设备提供的服务

3. 172.16.4.1  (可以使用为当前网络下 ,可以被访问的其他设备的web服务) 

4. http://class4  (class4名称是当前运行apache服务的计算机名) 相当于  www.baidu.com

    安装目录下的 : htdocs (存放网站程序的目录)  web服务默认会以网站根目录下 ,文件名为 index的文件作为当前站点的首页

   ---

   ###### 使用FTP 上传 文件 至服务器 

   ftp 地址 :  ftp://class4  

   账号: wt18

   密码: 123456

---

> 浏览器的地址栏 , 输入 www.baidu.com 然后按回车 =>  发生了什么事情?
>
> ##### 互联网上通信 , 只能通过 IP 地址进行寻址 .
>
> 1.按下回车 : 先对需要访问的域名进行解析   = >  DNS (域名解析 )  将域名解析为对应的 ip 地址 
>
> ​		解析:  1. 本地解析 (优先使用)  2. DNS服务解析
>
> 2.地址解析成功之后 , 就直接进行http请求访问...	 

###### 经常在开发场景中 , 需要模拟多站点通信  , apache 运行配置多个虚拟主机 :

1. ###### 配置本地的解析文件 : C:\Windows\System32\drivers\etc\hosts  (在很多软件破解时也会使用到)

   1. 配置一个本地域名 m.com
   2. 配置一个本地域名 s.com

~~~
127.0.0.1  		m.com
127.0.0.1  		s.com 
~~~

###### 2.配置apache 的虚拟主机 

找到apahce 的安装目录  (E:\xampp\apache\conf\extra\httpd-vhosts.conf)

参考配置如下:

~~~
#配置 s.com
<VirtualHost*:80>
    ServerAdmin admin@s.com
    DocumentRoot "/xampp/htdocs/s.com"
    ServerName s.com
</VirtualHost>

#配置 m.com
<VirtualHost*:80>
    ServerAdmin admin@m.com
    DocumentRoot "/xampp/htdocs/m.com"
    ServerName m.com
</VirtualHost>
~~~

所有的配置 ,修改完之后 ,都需要重启 apache 服务 生效.

---

搭环境与不搭环境的区别:

​	http服务环境:  http://m.com

​	没有环境: file:///E:/xampp/htdocs/s.com/index.html

---

##### jQuery 中的ajax:

###### 	(万能)ajax()

~~~javascript
ajax({
	url:"请求的服务器的url地址", //[必须]
    type:"get",// post , put , delete 请求方式   (method 也可以 , 效果一样)
    data:"需要发送给服务器的数据",
    dataType:'服务器返回的数据类型',//text , html ,css , script , json , jsonp
    async:true,//(默认为true) 是否异步操作 
    beforeSend:function(){//开始发送请求执行 执行
        
    },
    complete:function(){//请求过程结束(完成, 无论成功失败)
        
    },
    success:function(data){//请求成功的回调函数 ,  data 请求成功的数据
        
    },
    error:function(error){//请求失败 执行
        
    }
})
~~~

---

###### 异步: 在同一时刻 ,在执行一个任务时 ,也可以继续执行其他任务

###### 同步:在同一时刻,同时只能处理一个任务 (V8引擎 , 每次同时只能处理一个js任务) ,如果该任务还未执行完毕,那么下一个任务,就要等待该任务执行完之后才能进行.

  注意:浏览器js引擎是单线程应用,每次只能执行一个任务 , 如果此时为同步请求 ,(请求时间稍长一些就更明显) ,会导致js 引擎运行暂停(堵塞)  造成 = > "页面假死" 



###### 页面假死 : 1.页面的交互无响应 (右键无反应 , 包括浏览器中的一些事件处理都将失去反应)  2.暂停渲染

---

###### 	post() : 通过http post方式发起请求

~~~
post(请求服务器地址[必须],发送的数据,请求成功回调函数,服务器返回数据类型)
~~~

###### 	get() :通过http get方式发起请求

~~~
get(请求服务器地址[必须],发送的数据,请求成功回调函数,服务器返回数据类型)
~~~

###### 	getScript() : 通过http get请求方式 ,获取服务器上的一段 js脚本 ,并运行

~~~
getScript(请求服务器地址[必须])
~~~

######    load() : 使用在jQ对象上 ,直接把请求的内容显示到对应的DOM上

###### getJSON() : 使用get 请求 ,获取服务器上的json数据

---

(主流 )JSON : 是JavaScript 对象的表示方式 ,用于数据交换格式.

~~~js
//json格式 ,就是组键值对关系  = > 对象的形式 (通过对象属性方式调用 .属性名)
{
	"键名1":键值1,
    "键名2":键值2,
    "键名3":键值3   
}

//数组形式 (使用时候 ,用下标找到对应的对象 )
[
   {
	"键名1":键值1,
    "键名2":键值2,
    "键名3":键值3   
},{
	"键名1":键值1,
    "键名2":键值2,
    "键名3":键值3   
},{
	"键名1":键值1,
    "键名2":键值2,
    "键名3":键值3   
}
]

~~~



(已经逐步淘汰)XML: 是一种互联网应用交换数据格式 (xml是扩展型标记语言 ,类似于html)

###### XML与JSON的区别

~~~
详见 : https://www.jianshu.com/p/243deb64bcb5
~~~

###### 需要具备一定的数据结构设计能力. ( 对后端提供的数据要求 , 编写模拟数据)

模拟数据 , 数据结构与真实的后端接口数据格式一致 ,但是是本地模拟使用,用于在前后端开发时 ,后端暂未将后台的接口数据开发完时,提供前端本地开发模拟使用.

---

~~~js
轮播图:
	每张轮播图需要的数据 : 1. 图片的地址  2.图片的跳转链接地址
	{
		picUrl:"图片地址",
		url:"点击的超链接跳转地址"
	}

	
	[
		{
		  picUrl:"图片地址",
		  url:"点击的超链接跳转地址"
	   },{
		  picUrl:"图片地址",
		  url:"点击的超链接跳转地址"
	   },{
		  picUrl:"图片地址",
		  url:"点击的超链接跳转地址"
	   },{
		  picUrl:"图片地址",
		  url:"点击的超链接跳转地址"
	   },{
		  picUrl:"图片地址",
		  url:"点击的超链接跳转地址"
	   }
	]

例举京东单个商品展示列表 :
	商品的6款型号图片 \ 价格 \ 商品的标题 \ 评价的数量 \ 店铺的名称 \ 商品的跳转链接 \ 店铺的链接 \ 评价的跳转链接 \ 是否二手在售 ,跳转地址 \ 商品的特性 \ 商品的SID \ 是否广告 \ 客服的地址
~~~

---

##### 渲染: 

###### 	1.后端渲染:

​		服务端在返回 html 之前，在特定的区域，符号里用数据填充，再给客户端，客户端只负责解析 HTML 

​	

###### 	2.前端渲染(客户端渲染):

​		html 仅仅作为静态文件，客户端端在请求时，服务端不做任何处理，直接以原文件的形式返回给客户端客户端，然后根据 html 上的 JavaScript，生成 DOM 插入 html。



##### 前端渲染不利于SEO优化(内容需要在客户端通过js生成,所以爬虫抓取的时候是没有内容的,或者内容不多)

<https://www.jianshu.com/p/0719c6102639>

~~~
京东左侧导航分类 接口地址:https://dc.3.cn/category/get?&callback=getCategoryCallback
~~~

---

##### 发送数据:

###### GET请求方式

~~~
通过请求的地址中传递发送给后台的数据 = > QueryString (查询字符串)

http://m.com/api/?name=张三&age=20&sex=男
~~~

###### POST请求方式

~~~
通过post特定方式传输 
格式可以为 QueryString  / 表单数据 (字符串)
~~~

[注意] : 前后端数据交互中 , 没有json对象的概念 (php没有json对象的概念的,因为json是js中对象的表示形式)

虽然php中不存在json对象 ,但是为了更方便于前端js交互 ,后端有 json字符串(长得像json格式的字符串)的概念. (但是数据的类型其实就是字符串)

~~~
 一般的后台返回的数据格式 ,其实就是字符串类型数据 (只不过外观长得像json) = > json 字符串
~~~

---

##### 前端处理json字符串格式数据:

~~~
//1.json序列化  = > 将json字符串 , 解析为json对象  (方便js使用)
JSON.parse()

//2.json反序列化  = > 将json对象 ,转换为json字符串 (一般在发送对象格式数据给后台 , 进行对象格式数据的存储之类操作)
JSON.stringify()

~~~

---

##### 1.原生ajax (基础的原理)

~~~
 /*原生ajax :  XMLHttpRequest 对象 =  XHR
    *   属性:
            readyState: 请求过程状态
                    0:未初始化
                    1:正在建立连接
                    2:发送数据
                    3:接收数据 (并没有接收完毕)
                    4:接收数据完成 ,请求结束

            response:    响应内容
            responseText: 响应文本内容
            responseType: 响应内容类型
            responseURL:  响应服务器地址
            responseXML:  响应XML内容
            status: 0      http响应的状态码
            statusText:    http响应的状态文本提示内容
            timeout: 0     超时时间
    *
    *   方法:
    *       abort()  取消请求
    *       open()   建立连接(打开连接)
    *       send()   发送数据
    *       setRequestHeader() 设置请求包头
    *       getResponseHeader() 获取响应包头
    *       getAllResponseHeaders() 获取所有响应包头
    *
    *   事件:
    *       onabort: 取消事件
            onerror: 请求错误事件
            onload:  请求成功
            onloadend: 请求结束
            onloadstart: 开始请求
            onprogress: 请求的进度
            onreadystatechange: 请求过程状态改变事件
            ontimeout: 请求超时事件
            
            
       upload : 用于上传文件时使用 (H5文件操作再说)     
    *
    *
    * */
~~~



### 2.http协议

> HTTP（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。



>#### HTTP协议的特点 ：
>
>- http协议是一种无状态协议。（每次访问服务器时，没有办法识别身份）
>- 短连接协议（每次通信完毕就断开了）
>- http协议是一种单向通信协议（只能由客户的端主动向服务器发出请求，然后接受响应，服务器端不能主动给客户端发送消息）
>- 每次发起HTTP请求时，都会将浏览器缓存的cookie发送给服务器端。
>- 每次只能处理一个请求（两张图片，就是两个请求）
>- 简单、快捷、高效

###### http协议约定浏览器端与服务器端之间的通信规范:

从浏览器发起请求(数据包) :

###### Request : (告知服务器,我需要什么,你要做什么)

~~~
HTTP请求由状态行、请求头、请求正文三部分组成：
1.状态行：包括请求方式Method、资源路径URL、协议版本Version；
2.请求头：包括一些访问的域名、用户代理、Cookie等信息；
3.请求正文：就是HTTP请求的数据。
~~~



服务器响应客户端请求(数据包):

###### Response:(告知浏览器,我给了你什么,你该怎么玩)

~~~
HTTP响应由三部分组成：状态行、响应头、响应正文；
状态行：包括协议版本Version、状态码Status Code、回应短语；
响应头：包括搭建服务器的软件，发送响应的时间，回应数据的格式等信息；
响应正文：就是响应的具体数据。
备注：我们主要关心并且能够在客户端浏览器看得到的是三位数的状态码，不同的状态码代表不同的含义，其中
~~~



###### 常见的请求 / 响应包头:

```
Accept   : 定义客户端可以处理的媒体类型，按优先级排序 - > (告诉服务器,我能接受那些格式的文件)
Accept-Encoding :  定义客户端可以理解的编码机制。例如：Accept-Encoding:gzip,compress (能处理的编码方式)
Accept-Language    定义客户端乐于接受的自然语言列表。
Cache-Control      一个用于定义缓存指令的通用头标。例如：Cache-Control: max-age=30
Connection        一个用于表明是否保存socket连接为开放的通用头标 keep-alive
Contern-Type        标明发送或者接收的实体的MIME类型。例如：Content-Type: text/html(告诉服务器,我发送的数据内容类型)
Host            被请求资源的主机名。
If-Modified-Since        如果包含了GET请求，导致该请求条件性地依赖于资源上次修改日期。(用于校验文件是否最新,做缓存优化)
Server            一种标明Web服务器软件及其版本号的头标。
```

###### HTTP常见请求状态码

~~~
200 ok  = > 请求数据成功
304 	=>  请求内容与之前请求过的内容一样(暂未修改)
404		=>  服务器找不到请求的网页
500		=>	服务器内部错误
~~~

###### HTTP请求状态码

~~~
2**开头 （请求成功）表示成功处理了请求的状态代码。
200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。
201 （已创建） 请求成功并且服务器创建了新的资源。
202 （已接受） 服务器已接受请求，但尚未处理。
203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。
204 （无内容） 服务器成功处理了请求，但没有返回任何内容。
205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。
206 （部分内容） 服务器成功处理了部分 GET 请求。

3** 开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。
300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。
301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。
302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。
304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。
305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。
307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。

4**开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。
400 （错误请求） 服务器不理解请求的语法。
401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
403 （禁止） 服务器拒绝请求。
404 （未找到） 服务器找不到请求的网页。
405 （方法禁用） 禁用请求中指定的方法。
406 （不接受） 无法使用请求的内容特性响应请求的网页。
407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。
408 （请求超时） 服务器等候请求时发生超时。
409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。
410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。
411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。
412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。
413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。
414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。
415 （不支持的媒体类型） 请求的格式不受请求页面的支持。
416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。
417 （未满足期望值） 服务器未满足"期望"请求标头字段的要求。

5**开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。
500 （服务器内部错误） 服务器遇到错误，无法完成请求。
501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。
502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。
503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。
504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。
505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。
~~~

---

###### 模拟一个http通信过程:

~~~
小B(浏览器)  /  小S(服务器)

小B: 小S ,你在吗?
小S:在的
小B:最近手头有点紧,能不能借个100块钱救急?
小S:微信转账100 

....

过了一会(10天 ,也可能是5s后)
小B:小S ,你在吗?
小S:在的
小B:能不能借100块给我?
小S:支付宝转账100

...

~~~

##### 3.跨域 / 浏览器同源策略

###### 跨域:请求域与当前域中 , 只要有: 【端口 , 协议 , 域名】 任何一项不同 ,则视为跨域.

~~~
当前站点(域):http://localhost:63342/

目标请求站点(域):https://tcc.taobao.com  (域名, 协议 ,端口都不同)

目标域:http://localhost:8080    端口与当前域不同 ,属于跨域
目标域:http://lobaidu.com:63342 域名与当前域不同 ,属于跨域
目标域:https://localhost:63342/ 协议与当前域不同 ,属于跨域

~~~

##### 跨域的来源 = >  浏览器的同源策略

~~~
同源策略的目的是为了维护用户数据信息安全而定制的浏览器规则.
同源策略限定范围: http 请求  , cookie , 本地的存储类功能(localStorage , sessionStorage ,indexDB)

因为存在浏览器同源策略，所以才会有跨域问题。那么浏览器是出于何种原因会有跨域的限制呢。其实不难想到，跨域限制主要的目的就是为了用户的上网安全。

域之间域名\协议\端口都相同则视为同源.

浏览器对: script / link / img 三个标签引入资源没有限定
~~~

~~~
Access to XMLHttpRequest at 'https://tcc.taobao.com/cc/json/mobile_tel_segment.htm?tel=13800138000' (redirected from 'http://tcc.taobao.com/cc/json/mobile_tel_segment.htm?tel=13800138000') from origin 'null' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.
~~~

##### 解决跨域的方案:

~~~
1.jsonp
	解决方案: 在ajax的请求中 ,设置 dataType属性 为 jsonp, 即可.
	原理:因为浏览器中对于scrpt / img / link 标签的http请求 ,不作同源策略限制 ,所以就可以利用同在网页中加载js脚本的方式 ,引入一段跨域的脚本(返回的是一个方法 ,方法中是调用的方式 ,并且带有数据内容的实参)
需要在请求的时候 , 带上一个 callback 参数  ,来告知后台, 需要返回一个指定名字的函数 (需要后台支持)	
	特性: jsonp的请求方式只能为get请求 , 不适用于需要使用post请求的场景.
	
	动态创建 <script></script> 引入需要请求的数据地址 ,以脚本方式调用,获取返回的数据
------------------------------------------------------------------------------------

2.cors (跨域共享)
	原理: 就是通过服务器的响应包头 ,设定允许本次请求  ,浏览器收到请求后,就会放行.
	
	跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器  让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。
比如，站点 http://domain-a.com 的某 HTML 页面通过 <img> 的 src 请求 http://domain-b.com/image.jpg。网络上的许多页面都会加载来自不同域的CSS样式表，图像和脚本等资源。
	
	实现 : 以php为例:	
		php文件中添加:  header("Access-Control-Allow-Origin:*");

https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS

OPTIONS 方法的“预检请求” 用于检测服务端是否支持对应的包头字段 ,及请求类型 ,如果确认可以,才会正式发起对应的get / post请求
 header("Access-Control-Allow-Origin:*");
 header("Access-Control-Allow-Methods:POST,GET,OPTIONS");
 header("Access-Control-Allow-Headers:*");
------------------------------------------------------------------------------------
3.proxy

------------------------------------------------------------------------------------
4.websocket / postMessage

------------------------------------------------------------------------------------
5.iframe
~~~



---

